# -*- coding: utf-8 -*-
"""
Created on Sat Oct 27 20:48:49 2018

@author: Trevor Deane - Amplia Communications Ltd
"""


import sys
import os
from datetime import  datetime, timedelta
from lxml import etree
from lxml import objectify
import xmltodict
from zw2_functions import write_zw2_programme_info


# TVA_ROLE acts as a reference to convert GN Roles to TVAnywhere roles
# May be best to put these in a config file and read it in for ease of change
TVA_ROLE = {
    'Actor' :'urn:tva:metadata:TVARoleCS:ACTOR',
    'ACTOR' :'urn:tva:metadata:TVARoleCS:ACTOR',
    'Director' : 'urn:tva:metadata:TVARoleCS:DIRECTOR',
    'DIRECTOR' : 'urn:tva:metadata:TVARoleCS:DIRECTOR',
    'Author' : 'urn:tva:metadata:TVARoleCS:AUTHOR',
    'AUTHOR' : 'urn:tva:metadata:TVARoleCS:AUTHOR',
    'Writer' : 'urn:tva:metadata:TVARoleCS:AUTHOR',
    'WRITER' : 'urn:tva:metadata:TVARoleCS:AUTHOR',
    'Producer': 'urn:tva:metadata:TVARoleCS:PRODUCER',
    'PRODUCER': 'urn:tva:metadata:TVARoleCS:PRODUCER',
    }


#TVA_RATING_AGE acts as a refernece to convert US Parental Advice ratings
# into a minimum age for viewing the parogram
# May be best to put these in a config file and read it in for ease of change

TVA_RATING_AGE = {
    'TVG' : '0',
    'TVY' : '0',
    'TVY7' : '7',
    'TVPG' : '12',
    'TV14' : '14',
    'TVMA' : '18',
    '' : ''
    }

def get_event_data(element):
    """takes a list dict variable as generated by a xmltodict call
    containing the data for the specific event it places data into
    an eventData dict variable to be used to generate the output xml files
    The evenrData dict variable is returned
    """
    event_data = dict()
    event_data['program_id'] = element['@TMSId']
    event_data['program_date'] = element['@date']
    event_data['time_for_event'] = element['times']['time']
    event_data['duration_for_event'] = element['tv']['@dur']
    event_data['gmt_date_time_start'] = element['@date']+'T'+element['times']['time']+':00Z'
    event_data['gmt_date_time_start_zw2'] = event_data['program_date'][0:4]+\
        event_data['program_date'][5:7]+event_data['program_date'][8:] +\
        event_data['time_for_event'][0:2]+event_data['time_for_event'][3:]+ '00 +0000'
    end_time = datetime.strptime(event_data['gmt_date_time_start'], '%Y-%m-%dT%H:%M:%SZ') +\
        timedelta(hours=int(event_data['duration_for_event'][2:4]),\
                  minutes=int(event_data['duration_for_event'][5:7]))
    event_data['gmt_date_time_end'] = end_time.strftime('%Y-%m-%dT%H:%M:%SZ')
    event_data['gmt_date_time_end_zw2'] = end_time.strftime('%Y%m%d%H%M%S +0000')
    try:
        event_data['quals'] = element['quals']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        event_data['quals'] = ''
    return event_data



def get_list_of_channels(day):
    """for a variable containing the day it creates a BaseX call to the
    GraceNote Schedules file for that day and returns a list containing the
    channels in the schedule file for that day
    The BaseX server is assumed to be running on the local server
    """
#    have to set up logic to look at the specific files associated with the day
#    testday = day
    from BaseXClient import BaseXClient
    try:
        session = BaseXClient.Session('localhost', 1984, 'admin', 'admin')
    except IOError:
        print("BaseX server not running please start it before continuing")
        sys.exit(0)
    try:
        channel = []
        # create query instance
        query_string = "for $X in doc('GraceNoteSchedules')//schedules return $X/schedule/@sourceId"
        query = session.query(query_string)
        query_result_returned = query.execute()

        for channel_element in query_result_returned.split("\n"):
            channel.append(channel_element.strip()[10:-1])

        query.close()
        return channel
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        print("BaseX server not running please start it before continuing")
        sys.exit(0)
    finally:
        # close session
        if session:
            session.close()
    return channel



def get_list_of_events_objects(channel):
    """for a variable containing the channel it creates a BaseX call to the
    GraceNote Schedules file for that day and returns a string containing an xml variable
    with the events in the schedule file for that channel
    The BaseX server is assumed to be running on the local server
    """


    from BaseXClient import BaseXClient
    session = BaseXClient.Session('localhost', 1984, 'admin', 'admin')

    try:
        # create query instance
        query_string = 'for  $X in doc("GraceNoteSchedules")\
                //schedules/schedule where $X/@sourceId = "'+\
        channel + '"   return   $X/*'
        query = session.query(query_string)
        result = query.execute()

        new_xml_result = '<xml>' + result + "</xml>"
        query.close()
        return new_xml_result


    finally:
        # close session
        if session:
            session.close()
    return new_xml_result

def get_gracenote_xml_for_title(tms_id):
    """for a variable containing the programID it creates a BaseX call to the
    GraceNote Programmes file for that day and returns a string containing an xml variable
    with the program data in the programmes file for that programID
    The BaseX server is assumed to be running on the local server
    """
    from BaseXClient import BaseXClient
    try:
        session = BaseXClient.Session('localhost', 1984, 'admin', 'admin')
        # create query instance
        query_string =\
            "for $X in doc('GraceNotePrograms')//on/programs/program where $X/@TMSId = '"\
            + tms_id + "'   return  $X/* "
        query = session.query(query_string)
        query_result = query.execute()

        new_xml_result = '<xml>' + query_result + "</xml>"
        query.close()
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        print("BaseX server not running please start it before continuing")
        raise
    finally:
        # close session
        if session:
            session.close()

    return new_xml_result

def get_gracenote_season_id(tms_id, season_or_series):
    """for a ProgramID and a string which either is 'season' or 'series'
    it does a baseX call to Gracenote On Programs for that ProgramID and
    either returns the series_id or the season_id as appropriate
    The BaseX server is assumed to be running on the local server
    """
    from BaseXClient import BaseXClient
    try:
        session = BaseXClient.Session('localhost', 1984, 'admin', 'admin')
        query_string =\
            "for $X in doc('GraceNotePrograms')//on/programs/program where $X/@TMSId = '" +tms_id \
            + "'  return  $X/[@" + season_or_series +"] "
        query = session.query(query_string)
        query_result = query.execute()
        query.close()
        return query_result[11:-2]
    finally:
        if session:
            session.close()
    return ''

def create_root():
    """This function generates the lxml root element for the Zappware 4 xml tree
    It  includes all of the necessary namespaces and returns the root element
    """
#    from lxml import builder


    NSMAP = {None: 'urn:tva:metadata:2015',
             'xsi': 'http://www.w3.org/2001/XMLSchema-instance',
             'mpeg7': 'urn:tva:mpeg7:2008',
             'xsd': 'http://www.w3.org/2001/XMLSchema',
             'sds': 'urn:zw:sds-evo:2016'}

    root = objectify.Element('TVAMain', nsmap=NSMAP)
    root.set('{http://www.w3.org/XML/1998/namespace}lang', 'EN')
#    change

    return root

def create_main_tables(root, channel):
    """ This function takes the lxml root element and the channelID for the ZW4 xml and creates
    the main table heaings
    """
    program_description = objectify.Element("ProgramDescription")
    root.append(program_description)
    program_information_table = objectify.Element("ProgramInformationTable")
    program_description.append(program_information_table)



    group_information_table = objectify.Element("GroupInformationTable")
    program_description.append(group_information_table)

## Create program_location_table Tag
##
    program_location_table = objectify.Element("ProgramLocationTable")
    program_description.append(program_location_table)
    objectify.SubElement(program_location_table, "Schedule").set("serviceIDRef", channel)

## Create service_information_table Tag
##
    service_information_table = objectify.Element("ServiceInformationTable")
    program_description.append(service_information_table)

## Create program_review_table Tag
##
    program_review_table = objectify.Element("ProgramReviewTable")
    program_description.append(program_review_table)



    return {"program_description":program_description,
            "program_information_table": program_information_table,
            "group_information_table":group_information_table,
            "program_location_table":program_location_table,
            "service_information_table":service_information_table,
            "program_review_table":program_review_table
           }
def get_gracenote_source(source_filename):
    """This function takes a filename for the GraceNote ON sources XML for the day
    and returns and xmltodict variable containing the channel information
    from that file
    """
    #will need logic to select source file for day
#    filename = 'graceNoteInputFiles/on_car_samp_tv_sources_v22_20181012.xml'
    #now passed in to the function
    with open(source_filename) as file_handle:
        doc = xmltodict.parse(file_handle.read())
    return doc

def get_service_info(channel, source_filename):
    """This function takes a channelID and the filename for the GraceNote ON sources
    XML for the day and returns relevant channel information in a list variable
    """
    gracenote_sched = get_gracenote_source(source_filename)
    service_info = dict()
    for element in gracenote_sched['on']['sources']['prgSvcs']['prgSvc']:

        if element['@sourceId'] == channel:
            break
    service_info["serviceId"] = channel
    service_info["name"] = element['name']
    service_info["callSign"] = element['callSign']
    service_info["lang"] = element['bcastLangs']['bcastLang']
    return service_info

def insert_service_info_table(service_information_table, service_info):
    """ This function takes an lxml objectify object with the Service Information
    Table, as well as the dict variable with the service Information for the channel
    and adds the relevant information to the Service Information Table lxml object
    that was passed to it
    """

    service_information = objectify.SubElement(service_information_table, "ServiceInformation")
    service_information.set("serviceId", service_info["serviceId"])
    service_information.Name = service_info["callSign"]
    try:
        service_information.Name.set("{http://www.w3.org/XML/1998/namespace}lang",
                                     check_if_list(service_info["lang"]))
#        if isinstance(serviceInfo["lang"], list):
#            serviceInformation.Name.set("{http://www.w3.org/XML/1998/namespace}lang",
#                                        serviceInfo["lang"][0])
#        else:
#            serviceInformation.Name.set("{http://www.w3.org/XML/1998/namespace}lang",
#                                    serviceInfo["lang"])
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        service_information.Name.set("{http://www.w3.org/XML/1998/namespace}lang", '')
    return

def check_if_list(variable_to_check):
    """Function that takes a variable and checks to see if it is a list or
    a simple variable, if it is a list it returns the first element from the list,
    if it is a variable it returns the variable
    """
    if isinstance(variable_to_check, list):
        return variable_to_check[0]
    else:
        return variable_to_check




def create_schedule(event_data):
    """Function which takes an lxml dict variable with the event Data
    and returns a dict variable with the specific data required for the new
    xml files for the schedule
    """
    schedule = dict(
        Schedule_att_serviceIDRef="Schedule",
        ScheduleScheduleEventProgram_att_crid=event_data['program_id'],
        ScheduleScheduleEventProgramURL="",
        ScheduleScheduleEventPublishedStartTime=event_data['gmt_date_time_start'],
        ScheduleScheduleEventPublishedEndTime=event_data['gmt_date_time_end']
        )
    return schedule

def fill_program_location_table(program_location_table, event_data):
    """Function which takes the lxml objectify Program Location Table object
    along with the event_data list variable and adds the relevant entries to
    the program location table lxml object
    """
    schedule = create_schedule(event_data)
    schedule_obj = objectify.SubElement(program_location_table.Schedule, "ScheduleEvent")
#    schedule_obj.set("serviceIDRef", schedule["Schedule_att_serviceIDRef"])
#    schedule_obj.ScheduleEvent = ""
    schedule_obj.Program = ""
    schedule_obj.Program.set("crid", schedule["ScheduleScheduleEventProgram_att_crid"])
    schedule_obj.ProgramURL = schedule["ScheduleScheduleEventProgramURL"]
    schedule_obj.PublishedStartTime =\
        schedule["ScheduleScheduleEventPublishedStartTime"]
    schedule_obj.PublishedEndTime =\
        schedule["ScheduleScheduleEventPublishedEndTime"]



def handle_event(main_tables, event_data, program_ids_already_used, group_ids_already_used,
                 GENREMATCH, root_zw2, service_info, graphics_assets, zw2_graphics_assets,
                 amplia_channels):
    """This function is the main driving function which handles all aspects of
    dealing with a specific event.
    """
    result = get_gracenote_xml_for_title(event_data['program_id'])
    grace_note_dict = xmltodict.parse(result)
    series_id = get_gracenote_season_id(event_data['program_id'], 'series_id')
    season_id = get_gracenote_season_id(event_data['program_id'], 'season_id')
    b_d_unique = []
    b_d_unique = create_b_d_unique(grace_note_dict, event_data['program_id'], season_id)
    b_d_credits = []
#    credits_list_item = []
    b_d_credits = create_b_d_credits(grace_note_dict)
#    b_d_synopsis = []
    b_d_synopsis = create_b_d_synopsis(grace_note_dict)
    b_d_genres = create_b_d_genre(grace_note_dict, GENREMATCH)

#check to see if programId already in structure if not add it
    match = 0
    for element in program_ids_already_used:
        if element == event_data['program_id']:
            match = 1
            break
    if match != 1:
        program_ids_already_used.append(event_data['program_id'])
        program_information_element =\
            build_program_information(main_tables["program_information_table"],
                                      event_data['program_id'])
        build_basic_description_unique(grace_note_dict, program_information_element,
                                       season_id, b_d_unique, b_d_credits, b_d_synopsis,
                                       b_d_genres, graphics_assets)

        fill_program_review_table(main_tables["program_review_table"], grace_note_dict,
                                  event_data['program_id'])

    #check to see if groupID already in structure if not add it
    match = 0
    for element in group_ids_already_used:
        if element == series_id:
            match = 1
            break
    if match != 1:
        group_ids_already_used.append(series_id)
        fill_group_table(main_tables["group_information_table"],
                         grace_note_dict, series_id, season_id, group_ids_already_used,
                         b_d_unique, graphics_assets)



    fill_program_location_table(main_tables["program_location_table"], event_data)
#    b_d_unique = create_b_d_unique(grace_note_dict, event_data['programId'], series_id)
#    serviceInfo = get_service_info(event_data['programId'])
    write_zw2_programme_info(root_zw2, event_data, b_d_unique, service_info,
                             grace_note_dict, b_d_credits, b_d_synopsis, b_d_genres,
                             zw2_graphics_assets, amplia_channels)


def finally_write_xml_file(root_of_objectivy_object, filename, BASEDIRECTORY, cleanup_namespaces,
                           xml_declaration):    #Write file
    """This function takes the root of th lxml objectify object along with the filename
    to write, the Basedirectory, and boolean flags signifying if to cleanup namespaces
    and if to write the xml declaration at the beginning of the file. It then
    writes the relevant xml file
    """

    objectify.deannotate(root_of_objectivy_object, cleanup_namespaces=cleanup_namespaces, xsi_nil=True)
    obj_xml = etree.tostring(root_of_objectivy_object,
                             pretty_print=True,
                             xml_declaration=xml_declaration)

    try:
        os.chdir(BASEDIRECTORY)
        print(filename)
        with open(filename, "wb") as xml_writer:
            xml_writer.write(obj_xml)
    except IOError:
        print("IO Error cannot write XML file ", filename)
        sys.exit()


def write_unique_sort_file(filename, array_to_write, BASEDIRECTORY):
    """This function takes a file name, a list variable with the list of images
    used and a base directory. It then gets a unique set of those images, sorts
    them and writes it to the file name in the Base directory
    """
    try:
        os.chdir(BASEDIRECTORY)
        file_writer = open(filename, "w")
        unique_array = list(set(array_to_write))
        unique_array.sort()
        for line in unique_array:
            if line != '':
                file_writer.write(line + "\n")
        file_writer.close()
    except IOError:
        print("IO Error cannot write file ", filename)
        sys.exit()



#This function uses the program information returned from the GN Program file for
#the specific TMSId and puts it into a structure b_d_unique which is used to hold
#the relevant data to be placed in the Program Information Table at a unique level
def create_b_d_unique(grace_note_dict, program_id, season_id):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, the programId and the season_id and generates
    a specific dict variable which has the information required for the non
    recurring information in the Programme Table Basic Description
    """
    b_d_unique = dict()
    b_d_unique['program_id'] = program_id
    b_d_unique['guid'] = program_id
    try:
        b_d_unique['BDKeyword'] = grace_note_dict['xml']['progType']['#text']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDKeyword'] = ''
    b_d_unique['BDKeyword_att_type'] = "main"


    b_d_unique['BDGenre_att_href'] = "rn:tva:metadata:cs:ContentCS:2011:14"
# This construct is here to check to see if the value returned exists, and if it
#exists if it is a list or a single value and put the relevant values into the
#variable
    try:
        if isinstance(grace_note_dict['xml']['ratings']['rating'], list):
            check = 0
            for element in grace_note_dict['xml']['ratings']['rating']:
                if element['@area'] == 'USA Parental Rating':
                    b_d_unique['BDParentalGuidanceMinimumAge'] = TVA_RATING_AGE[element['@code']]
                    check = 1
            if check == 0:
                b_d_unique['BDParentalGuidanceMinimumAge'] = ''

        else:
            element = grace_note_dict['xml']['ratings']['rating']
            if element['@area'] == 'USA Parental Rating':
                b_d_unique['BDParentalGuidanceMinimumAge'] = TVA_RATING_AGE[element['@code']]
            else:
                b_d_unique['BDParentalGuidanceMinimumAge'] = ''
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDParentalGuidanceMinimumAge'] = ''
#    b_d_unique['BDParentalGuidanceMinimumAge'] = "12"
    b_d_unique['BDCaptionLanguage'] = "eng"
    b_d_unique['BDCaptionLanguage_att_primary'] = "true"
# These constructs take care of if there is no data for this element in the
#grace_note_dict list. May be possible to have it as a function and just
#call it each time
    try:
        b_d_unique['BDProductionDateTimePoint'] = grace_note_dict['xml']['origAirDate']['#text']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDProductionDateTimePoint'] = ''
    try:
        b_d_unique['BDProductionDateDuration'] = grace_note_dict['xml']['runTime']['#text']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDProductionDateDuration'] = ''
    try:
        b_d_unique['BDProductionLocation'] = grace_note_dict['xml']['countries']['country']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDProductionLocation'] = ''
    try:
        if   isinstance(grace_note_dict['xml']['titles']['title'], list):
            b_d_unique['BDTitle'] = grace_note_dict['xml']['titles']['title'][0]['#text']
            b_d_unique['BDTitle_att_lang'] = grace_note_dict['xml']['titles']['title'][0]['@lang']
            b_d_unique['BDTitle_att_type'] = grace_note_dict['xml']['titles']['title'][0]['@type']
        else:
            b_d_unique['BDTitle'] = grace_note_dict['xml']['titles']['title']['#text']
            b_d_unique['BDTitle_att_lang'] = grace_note_dict['xml']['titles']['title']['@lang']
            b_d_unique['BDTitle_att_type'] = grace_note_dict['xml']['titles']['title']['@type']

    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['BDTitle'] = ""
        b_d_unique['BDTitle_att_lang'] = ""
        b_d_unique['BDTitle_att_type'] = ""
    try:
        b_d_unique["programEpisodeTitle"] = grace_note_dict['xml']['episodeInfo']['title']['#text']
        b_d_unique["programEpisodeTitle_att_lang"] =\
                grace_note_dict['xml']['episodeInfo']['title']['@lang']
        b_d_unique["programEpisodeTitle_att_type"] =\
                grace_note_dict['xml']['episodeInfo']['title']['@type']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique["programEpisodeTitle"] = ""
        b_d_unique["programEpisodeTitle_att_lang"] = ""
        b_d_unique["programEpisodeTitle_att_type"] = ""
    try:
        b_d_unique['infoMemberOf_att_index'] = grace_note_dict['xml']['episodeInfo']['@number']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        b_d_unique['infoMemberOf_att_index'] = ''
    return b_d_unique
#        b_d_synopsis=  get_gracenote_xml_for_title('MV000223680000')
def create_b_d_synopsis(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID,
    generates a specific dict variable which has the information required for the
    synopsis part of the Basic Description in the Programme Table
    """
    b_d_synopsis = []
    try:
        if   isinstance(grace_note_dict['xml']['descriptions']['desc'], list):
            for index, element in enumerate(grace_note_dict['xml']['descriptions']['desc']):
                length_type = ''
                if int(element['@size']) <= 90:
                    length_type = 'short'
                else:
                    if int(element['@size']) <= 210:
                        length_type = 'medium'
                    else:
                        if int(element['@size']) <= 1200:
                            length_type = 'long'
                b_d_synopsis.append({
                    "b_d_synopsis" : element['#text'],
                    "b_d_synopsis_att_lang" : element['@lang'],
                    "b_d_synopsis_att_length" : element['@size'],
                    "b_d_synopsis_length_type" : length_type,
                    "index" : index
                    })
        else:
            element = grace_note_dict['xml']['descriptions']['desc']
            if int(element['@size']) <= 90:
                length_type = 'short'
            else:
                if int(element['@size']) <= 210:
                    length_type = 'medium'
                else:
                    if int(element['@size']) <= 1200:
                        length_type = 'long'
                    else:
                        length_type = ''
            b_d_synopsis.append({
                "b_d_synopsis" : element['#text'],
                "b_d_synopsis_att_lang" : element['@lang'],
                "b_d_synopsis_att_length" : element['@size'],
                "b_d_synopsis_length_type" : length_type,
                "index" : "1"
                })
        return b_d_synopsis
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
#        pass
        return b_d_synopsis

def create_b_d_genre(grace_note_dict, GENREMATCH):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, along with a variable containing the
    cross reference between the GraceNote Genre and the TVAnywhere category and
    generates a specific dict variable which has the information required for the
    genres part of the Basic Description in the Programme Table. It places the
    relevant TVAnywhere genreID as per the variable matched.
    """
    b_d_genres = []
    try:
        if   isinstance(grace_note_dict['xml']['genres']['genre'], list):
            for element in grace_note_dict['xml']['genres']['genre']:
                b_d_genres.append({
                    "genre" : GENREMATCH[element['@genreId']],
                    "genreName" : element['#text']
                    })
        else:
            element = grace_note_dict['xml']['genres']['genre']
            b_d_genres.append({
                "genre" : GENREMATCH[element['@genreId']],
                "genreName" : element['#text']
                })
        return b_d_genres
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
#        pass
        return b_d_genres


def create_b_d_credits(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID,
    generates a specific dict variable which has the information required for the
    credits part of the Basic Description in the Programme Table
    """
    b_d_credits = []

    try:
        if isinstance(grace_note_dict['xml']['crew']['member'], list):
            for element in grace_note_dict['xml']['crew']['member']:
                if element['role'] in TVA_ROLE:
                    b_d_credits.append({
                        "b_d_creditsListCreditsItem_att_role" : TVA_ROLE[element['role']],
                        "BDPersonNameGivenName" : element['name']['first'],
                        "BDPersonNameFamilyName" : element['name']['last'],
                        "BDPersonNameRole" :  element['role']
                        })
        else:
            element = grace_note_dict['xml']['crew']['member']
            if element['role'] in TVA_ROLE:
                b_d_credits.append({
                    "b_d_creditsListCreditsItem_att_role" : TVA_ROLE[element['role']],
                    "BDPersonNameGivenName" : element['name']['first'],
                    "BDPersonNameFamilyName" : element['name']['last'],
                    "BDPersonNameRole" :  element['role']
                    })
#        return b_d_credits
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        pass
    try:
        if isinstance(grace_note_dict['xml']['cast']['member'], list):
            for element in grace_note_dict['xml']['cast']['member']:
                if element['role'] in TVA_ROLE:
                    b_d_credits.append({
                        "b_d_creditsListCreditsItem_att_role" : TVA_ROLE[element['role']],
                        "BDPersonNameGivenName" : element['name']['first'],
                        "BDPersonNameFamilyName" : element['name']['last'],
                        "BDPersonNameRole" :  element['role']
                        })
        else:
            element = grace_note_dict['xml']['cast']['member']
            if element['role'] in TVA_ROLE:
                b_d_credits.append({
                    "b_d_creditsListCreditsItem_att_role" : TVA_ROLE[element['role']],
                    "BDPersonNameGivenName" : element['name']['first'],
                    "BDPersonNameFamilyName" : element['name']['last'],
                    "BDPersonNameRole" :  element['role']
                    })
        return b_d_credits
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
#        pass
        return b_d_credits



def create_b_d_related(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID,
    generates a specific dict variable which has the information required for the
    related assets part of the Basic Description in the Programme Table
    """
    b_d_related = []
    try:
        if isinstance(grace_note_dict['xml']['assets']['asset'], list):
            for element in grace_note_dict['xml']['assets']['asset']:
                if element['@width'] == '1920' and element['@height'] == '1080'\
                and (element['@tier'] != 'Season' or  element['@tier'] != 'Series'):
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                    b_d_related.append({
                        "b_d_relatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })
                if element['@width'] == '1138' and element['@height'] == '640'\
                and (element['@tier'] != 'Season' or  element['@tier'] != 'Season'):
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                    b_d_related.append({
                        "b_d_relatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })

        else:
            if element['@width'] == '1920' and element['@height'] == '1080'\
            and (element['@tier'] != 'Season' or  element['@tier'] != 'Series'):
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                b_d_related.append({
                    "b_d_relatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
            if element['@width'] == '1138' and element['@height'] == '640'\
            and (element['@tier'] != 'Season' or  element['@tier'] != 'Season'):
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                b_d_related.append({
                    "b_d_relatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
        return b_d_related
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        return b_d_related
#        pass

def create_b_d_related_series(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID,
    generates a specific dict variable which has the information required for the
    related assets for the SERIES entry for this programID in the group Table
    """
    b_d_related_group_series = []
    try:
        if isinstance(grace_note_dict['xml']['assets']['asset'], list):
            for element in grace_note_dict['xml']['assets']['asset']:
                if element['@width'] == '1920' and element['@height'] == '1080'\
                and element['@tier'] == 'Series':
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                    b_d_related_group_series.append({
                        "BDRelatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })
                if element['@width'] == '1138' and element['@height'] == '640'\
                and element['@tier'] == 'Series':
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                    b_d_related_group_series.append({
                        "BDRelatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })

        else:
            if element['@width'] == '1920' and element['@height'] == '1080'\
            and element['@tier'] == 'Series':
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                b_d_related_group_series.append({
                    "BDRelatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
            if element['@width'] == '1138' and element['@height'] == '640'\
            and element['@tier'] == 'Series':
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                b_d_related_group_series.append({
                    "BDRelatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
        return b_d_related_group_series
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        return b_d_related_group_series


def create_b_d_related_season(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID,
    generates a specific dict variable which has the information required for the
    related assets for the SEASON entry for this programID in the group Table
    """
    b_d_related_group_season = []
    try:
        if isinstance(grace_note_dict['xml']['assets']['asset'], list):
            for element in grace_note_dict['xml']['assets']['asset']:
                if element['@width'] == '1920' and element['@height'] == '1080'\
                and element['@tier'] == 'Season':
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                    b_d_related_group_season.append({
                        "BDRelatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })
                if element['@width'] == '1138' and element['@height'] == '640'\
                and element['@tier'] == 'Season':
                    href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                    b_d_related_group_season.append({
                        "BDRelatedMaterialHowRelated_att_href" : href,
                        "BDMediaLocatorMediaUri" : element['URI']
                        })

        else:
            if element['@width'] == '1920' and element['@height'] == '1080'\
            and element['@tier'] == 'Season':
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.1"
                b_d_related_group_season.append({
                    "BDRelatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
            if element['@width'] == '1138' and element['@height'] == '640'\
            and element['@tier'] == 'Season':
                href = "urn:tva:metadata:cs:HowRelatedCS:2012:19.2"
                b_d_related_group_season.append({
                    "BDRelatedMaterialHowRelated_att_href" : href,
                    "BDMediaLocatorMediaUri" : element['URI']
                    })
        return b_d_related_group_season
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        return b_d_related_group_season


def create_group_info_series_unique(grace_note_dict, series_id, season_id):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, along with seriedID and the season_id and
    generates a specific dict variable which has the information required for the
    non recurring  entry for this programID in the SERIES entry in the group Table
    """
    group_info_series_unique = dict()
    group_info_series_unique['Ginfo_att_groupId'] = series_id
    group_info_series_unique['Ginfo_att_guid'] = series_id
    group_info_series_unique['Ginfo_att_ordered'] = 'false'
    try:
        group_info_series_unique['GinfoGroupType_att_type'] = 'ProgramGroupTypeType'
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_series_unique['GinfoGroupType_att_type'] = 'ProgramGroupTypeType'
    try:
        group_info_series_unique['Ginfo_att_value'] = 'series'
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_series_unique['Ginfo_att_value'] = ''
    try:
        group_info_series_unique['GinfoMemberOf_att_index'] =\
                grace_note_dict['xml']['episodeInfo']['@number']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_series_unique['GinfoMemberOf_att_index'] = ""
    group_info_series_unique['GinfoMemberOf_att_crid'] = season_id
    return group_info_series_unique


def create_group_info_series_title(grace_note_dict):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, along with seriedID and the season_id and
    generates a specific dict variable which has the information required for the
    possibly recurring  title entry for this programID in the SERIES entry in the group Table
    """
    group_info_series_title = []
    try:
        if isinstance(grace_note_dict['xml']['episodeInfo']['title'], list):
            for element in grace_note_dict['xml']['episodeInfo']['title']:
                group_info_series_title.append({
                    "GinfoBasicDescriptionTitleValue" : element['#text'],
                    "GinfoBasicDescriptionTitle_att_lang" : element['@lang'],
                    "GinfoBasicDescriptionTitle_att_type" : element['@type']
                    })
        else:
            element = grace_note_dict['xml']['episodeInfo']['title']
            group_info_series_title.append({

                "GinfoBasicDescriptionTitleValue" : element['#text'],
                "GinfoBasicDescriptionTitle_att_lang" : element['@lang'],
                "GinfoBasicDescriptionTitle_att_type" : element['@type']
                })


        return group_info_series_title
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        return group_info_series_title


#def createGroupInfoSeriesMultipleHowTitle():
#    groupInfoSeriesMultipleHowTitle = []
#    groupInfoSeriesMultipleHowTitle.append({
#        "GinfoBDRelatedMaterialHowRelated_att_href" : "urn:tva:metadata:cs:HowRelatedCS:2012:19.1",
#        "GinfoBDRelatedMaterialMediaUri" : "./1920x1080_p11475147_e_h10_aa_1.jpg"
#        })
#    groupInfoSeriesMultipleHowTitle.append({
#        "GinfoBDRelatedMaterialHowRelated_att_href" : "urn:tva:metadata:cs:HowRelatedCS:2012:20.1",
#        "GinfoBDRelatedMaterialMediaUri" : "./1020x768_p11475147_e_h10_aa_1.jpg"
#        })
#    return groupInfoSeriesMultipleHowTitle


def create_group_info_season_unique(grace_note_dict, series_id, season_id):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, along with seriedID and the season_id and
    generates a specific dict variable which has the information required for the
    non recurring  entry for this programID in the SEASON entry in the group Table
    """
    episode_of = dict()
    try:
        episode_of['episodeOf_att_crid'] = ''
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        episode_of['episodeOf_att_crid'] = ''

    group_info_season_unique = dict()

    group_info_season_unique['Ginfo_att_groupId'] = season_id

    group_info_season_unique['Ginfo_att_guid'] = season_id

    group_info_season_unique['Ginfo_att_ordered'] = 'false'
    try:
        group_info_season_unique['GinfoGroupType_att_type'] = 'ProgramGroupTypeType'
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_season_unique['GinfoGroupType_att_type'] = 'ProgramGroupTypeType'
    try:
        group_info_season_unique['Ginfo_att_value'] = 'season'
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_season_unique['Ginfo_att_value'] = ''
    try:
        group_info_season_unique['GinfoMemberOf_att_index'] =\
                grace_note_dict['xml']['episodeInfo']['@season']
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        group_info_season_unique['GinfoMemberOf_att_index'] = ''
    group_info_season_unique['GinfoMemberOf_att_crid'] = series_id
    return group_info_season_unique

def create_review_data(grace_note_dict, program_id):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID and the programId and generates
    a specific dict variable which has the information required for the Review Data
    """

    review_data = []
    try:
        if isinstance(grace_note_dict['xml']['ratings']['qualityRating'], list):
            for element in grace_note_dict['xml']['ratings']['qualityRating']:
                review_data.append({
                    "Review_att_programId" : program_id,
                    "ReviewRatingRatingValue" : element['name']['#text'],
                    "ReviewRatingRatingScheme_att_style" : "higherBetter",
                    "ReviewRatingRatingSchemeName" : element['name']['#text']
                })
        else:
            element = grace_note_dict['xml']['ratings']['qualityRating']
            review_data.append({
                "Review_att_programId" : program_id,
                "ReviewRatingRatingValue" : element['name']['#text'],
                "ReviewRatingRatingScheme_att_style" : "higherBetter",
                "ReviewRatingRatingSchemeName" : element['name']['#text']
            })
        return review_data
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        return review_data

def build_basic_description_unique(grace_note_dict, program_information_element,
                                   season_id, b_d_unique, b_d_credits,
                                   b_d_synopsis, b_d_genres, graphics_assets):
    """This function takes the xmltodict list variable which was created from the
    xml data for the specific programID, the lxml objectify element for the
    Program Information Table element, the season_id as well as various specific
    dict variable generated for the relevant portions of the Basic Description
    Table and finally a variable which has the list of graphic assets used. It then
    appends the relevant lxml objects to creat the Basic Description Table. It also
    appends the images used to the graphics assets used variable
    """

    basic_description = objectify.SubElement(program_information_element, "BasicDescription")
    if b_d_unique['programEpisodeTitle'] == '':
        basic_description.Title = b_d_unique["BDTitle"]
        basic_description.Title.set("{http://www.w3.org/XML/1998/namespace}lang",
                                    b_d_unique["BDTitle_att_lang"])
        basic_description.Title.set("type", b_d_unique["BDTitle_att_type"])
    else:
        basic_description.Title = b_d_unique["programEpisodeTitle"]
        basic_description.Title.set("{http://www.w3.org/XML/1998/namespace}lang",
                                    b_d_unique["programEpisodeTitle_att_lang"])
        basic_description.Title.set("type", b_d_unique["programEpisodeTitle_att_type"])
    basic_description.Title.set("{http://www.w3.org/XML/1998/namespace}lang",
                                b_d_unique["BDTitle_att_lang"])
    basic_description.Title.set("type", b_d_unique["BDTitle_att_type"])
    basic_description.Keyword = b_d_unique["BDKeyword"]
    basic_description.Keyword.set("type", b_d_unique["BDKeyword_att_type"])
#    bDGenre = create_b_d_genre(grace_note_dict, GENREMATCH)

    for element in b_d_genres:
        genre_data = element['genre']
        objectify.SubElement(program_information_element, "Genre").set('href', genre_data)


    basic_description.ParentalGuidance = ""
    objectify.SubElement(basic_description.ParentalGuidance,
                         "{urn:tva:mpeg7:2008}MinimumAge").\
                         _setText(b_d_unique["BDParentalGuidanceMinimumAge"])
#    basic_description.ParentalGuidance.MinimumAge = b_d_unique["BDParentalGuidanceMinimumAge"]
    basic_description.CaptionLanguage = b_d_unique["BDCaptionLanguage"]
    basic_description.CaptionLanguage.set("primary", b_d_unique["BDCaptionLanguage_att_primary"])
    basic_description.CreditsList = ""
    basic_description.RelatedMaterial = ""
    basic_description.ProductionDate = ""
    basic_description.ProductionDate.TimePoint = b_d_unique["BDProductionDateTimePoint"]
    basic_description.ProductionDate.Duration = b_d_unique["BDProductionDateDuration"]
    basic_description.ProductionLocation = b_d_unique["BDProductionLocation"]
    synopsis = []
#    b_d_synopsis = create_b_d_synopsis(grace_note_dict)
    for index, b_d_synopsis_element in enumerate(b_d_synopsis):
        synopsis_temp = objectify.SubElement(basic_description, "Synopsis")
        synopsis.append(synopsis_temp)
        synopsis[index]._setText(b_d_synopsis_element["b_d_synopsis"])
        synopsis[index].set("{http://www.w3.org/XML/1998/namespace}lang",
                            b_d_synopsis_element["b_d_synopsis_att_lang"])
        synopsis[index].set("length", b_d_synopsis_element["b_d_synopsis_length_type"])
        synopsis[index].set("lengthNumber", b_d_synopsis_element["b_d_synopsis_att_length"])


    credits_list_item = []
    index = 0
    for b_d_credits_element in b_d_credits:
        if b_d_credits_element["BDPersonNameRole"].upper() != "PRODUCER":
            credits_list_item_temp = objectify.SubElement(basic_description.CreditsList,
                                                          "CreditsListitem")
            credits_list_item.append(credits_list_item_temp)
            credits_list_item[index].CreditsItem = ""
            credits_list_item[index].CreditsItem.\
                    set("role", b_d_credits_element["b_d_creditsListCreditsItem_att_role"])
            credits_list_item[index].CreditsItem.PersonName = ''
            objectify.SubElement(credits_list_item[index].CreditsItem.PersonName,
                                 "{urn:tva:mpeg7:2008}GivenName").\
                                 _setText(b_d_credits_element["BDPersonNameGivenName"])
            objectify.SubElement(credits_list_item[index].CreditsItem.PersonName,
                                 "{urn:tva:mpeg7:2008}FamilyName").\
                                 _setText(b_d_credits_element["BDPersonNameFamilyName"])
            index = index + 1
    b_d_related = []
    b_d_related = create_b_d_related(grace_note_dict)
    for b_d_related_element in b_d_related:
        basic_description.RelatedMaterial.HowRelated = ''
        basic_description.RelatedMaterial.HowRelated.\
                set("href", b_d_related_element["b_d_relatedMaterialHowRelated_att_href"])
        basic_description.RelatedMaterial.MediaLocator = ""
        basic_description.RelatedMaterial.MediaLocator.MediaUri =\
                b_d_related_element["BDMediaLocatorMediaUri"]
        graphics_assets.append(b_d_related_element["BDMediaLocatorMediaUri"])
    if season_id != '':
        episode_info_obj = objectify.SubElement(program_information_element, "EpisodeOf")
        episode_info_obj.set('crid', season_id)
        episode_info_obj.set('index', b_d_unique['infoMemberOf_att_index'])

    return


#
def build_group_info_series_unique(group_information_table, grace_note_dict,
                                   series_id, season_id, b_d_unique):
    """This function takes the lxml objectify element for the Group Information
    Table element,the xmltodict list variable which was created from the
    xml data for the specific programID,  the series and season IDs as well as a
    dict variable generated for the relevant portion of the Basic Description
    Table. It then appends the relevant lxml objects to create the SERIES portion of
    the Group Information Table.
    """
    group_info_series_unique = create_group_info_series_unique(grace_note_dict, series_id,
                                                               season_id)
    group_info_series_title = create_group_info_series_title(grace_note_dict)
    group_information = objectify.SubElement(group_information_table, "GroupInformation")
    group_information.set("groupId", group_info_series_unique["Ginfo_att_groupId"])
    group_information.set("{urn:zw:sds-evo:2016}guid", group_info_series_unique["Ginfo_att_guid"])
    group_information.set("ordered", group_info_series_unique["Ginfo_att_ordered"])
    group_information.GroupType = ''
    group_information.GroupType.set("type", group_info_series_unique["GinfoGroupType_att_type"])
    group_information.GroupType.set("value", group_info_series_unique["Ginfo_att_value"])
    group_information.BasicDescription = ""
    group_information.BasicDescription.Title = b_d_unique['BDTitle']
    group_information.BasicDescription.Title.set("{http://www.w3.org/XML/1998/namespace}lang",
                                                 b_d_unique["BDTitle_att_lang"])
    group_information.BasicDescription.RelatedMaterial = ""
    try:
        for group_title_element in group_info_series_title:
            group_information.BasicDescription.Title =\
                    group_title_element["GinfoBasicDescriptionTitleValue"]
            group_information.BasicDescription.Title.\
                    set("{http://www.w3.org/XML/1998/namespace}lang",
                        group_title_element["GinfoBasicDescriptionTitle_att_lang"])
            group_information.BasicDescription.Title.\
                    set("type", group_title_element["GinfoBasicDescriptionTitle_att_type"])
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        pass
    try:
        b_d_related_series = []
        b_d_related_series = create_b_d_related_series(grace_note_dict)
        for b_d_related_element in b_d_related_series:
            group_information.BasicDescription.RelatedMaterial.HowRelated = ''
            group_information.BasicDescription.RelatedMaterial.HowRelated.\
                    set("href", b_d_related_element["BDRelatedMaterialHowRelated_att_href"])
            group_information.BasicDescription.RelatedMaterial.MediaLocator = ""
            group_information.BasicDescription.RelatedMaterial.MediaLocator.MediaUri =\
                    b_d_related_element["BDMediaLocatorMediaUri"]
            graphics_assets.append(b_d_related_element["BDMediaLocatorMediaUri"])
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        pass

def build_group_info_season_unique(group_information_table, grace_note_dict, series_id,
                                   season_id, graphics_assets):
    """This function takes the lxml objectify element for the Group Information
    Table element,the xmltodict list variable which was created from the
    xml data for the specific programID,  the series and season IDs as well as a
    variable which has the list of graphic assets used. It then appends the relevant
    lxml objects to create the SEASON portion of the Group Information Table. It also
    appends the images used to the graphics assets used variable
    """
    group_info_season_unique = create_group_info_season_unique(grace_note_dict, series_id,
                                                               season_id)
    group_information = objectify.SubElement(group_information_table, "GroupInformation")
    group_information.set("groupId", group_info_season_unique["Ginfo_att_groupId"])
    group_information.set("{urn:zw:sds-evo:2016}guid", group_info_season_unique["Ginfo_att_guid"])
    group_information.set("ordered", group_info_season_unique["Ginfo_att_ordered"])
    group_information.GroupType = ''
    group_information.GroupType.set("type", group_info_season_unique["GinfoGroupType_att_type"])
    group_information.GroupType.set("value", group_info_season_unique["Ginfo_att_value"])
    group_information.MemberOf = ""
    group_information.MemberOf.set("crid", group_info_season_unique["GinfoMemberOf_att_crid"])
    group_information.MemberOf.set("index", group_info_season_unique["GinfoMemberOf_att_index"])
    group_information.BasicDescription = ""
    group_information.BasicDescription.RelatedMaterial = ""
    try:
        b_d_related_season = []
        b_d_related_season = create_b_d_related_season(grace_note_dict)
        for b_d_related_element in b_d_related_season:
            group_information.BasicDescription.RelatedMaterial.HowRelated = ''
            group_information.BasicDescription.RelatedMaterial.HowRelated.\
                    set("href", b_d_related_element["BDRelatedMaterialHowRelated_att_href"])
            group_information.BasicDescription.RelatedMaterial.MediaLocator = ""
            group_information.BasicDescription.RelatedMaterial.MediaLocator.MediaUri =\
                    b_d_related_element["BDMediaLocatorMediaUri"]
            graphics_assets.append(b_d_related_element["BDMediaLocatorMediaUri"])
    except (UnboundLocalError, KeyError, IndexError, LookupError, NameError, ValueError):
        pass

def fill_program_review_table(program_review_table, grace_note_dict, program_id):
    """This function takes the lxml objectify element for the Group Information
    Table element,the xmltodict list variable which was created from the
    xml data for the specific programID, and the programID and appends the relevant
    lxml objects to create the Rating Table
    """
    review_data = create_review_data(grace_note_dict, program_id)
    review = []
    for index, review_data_element in enumerate(review_data):
        review_temp = objectify.SubElement(program_review_table, "Review")
        review.append(review_temp)
        review[index]._setText(review_data_element["Review_att_programId"])
        review[index].Rating = ""
        objectify.SubElement(review[index].Rating, "{urn:tva:mpeg7:2008}GivenName")._setText(
            review_data_element["ReviewRatingRatingValue"])
        objectify.SubElement(review[index].Rating, "{urn:tva:mpeg7:2008}RatingScheme").set(
            "style", review_data_element["ReviewRatingRatingScheme_att_style"])

        review[index].Rating.RatingScheme.\
            set("style", review_data_element["ReviewRatingRatingScheme_att_style"])
        objectify.SubElement(review[index].Rating.RatingScheme, "{urn:tva:mpeg7:2008}Name").\
            setText(review_data_element["ReviewRatingRatingSchemeName"])

    return

def build_program_information(program_information_table, program_id):
    """This function takes the lxml objectify object for the Program Information
    Table and the programID, and builds the outer object for the programID
    """
    program_information_element = objectify.SubElement(program_information_table,
                                                       "ProgramInformation")
    program_information_element.set("programId", program_id)
    program_information_element.set("{urn:tva:mpeg7:2008}guid", program_id)
    return program_information_element


def fill_group_table(group_information_table, grace_note_dict, series_id, season_id,
                     group_ids_already_used, b_d_unique, graphics_assets):
    """This function takes the lxml objectify object for the Program Information
    Table, the xmltodict list variable which was created from the
    xml data for the specific programID. the series_id, the season_id, a variable
    with a list of the groupIDs which have already been placed in the lxml object,
    a dict variable generated for the relevant portion of the Basic Description
    Table and a variable which has the list of graphic assets used. It then checks to
    see if the group series has already been used, if not it calls the function to
    process this group for the series and similarly for the season
    """
    build_group_info_series_unique(group_information_table, grace_note_dict, series_id,
                                   season_id, b_d_unique)
    if season_id != '':
        match = 0
        for element in group_ids_already_used:
            if element == season_id:
                match = 1
                break
        if match != 1:
            group_ids_already_used.append(season_id)
            build_group_info_season_unique(group_information_table, grace_note_dict,
                                           series_id, season_id, graphics_assets)
    return

def append_schedule(program_location_table, schedule):
    """This function takes the lxml objectify object for the Program Location
    Table and  the xmltodict list variable which was created from the
    xml data for the schedule. It then appends the schedule object data to
    the Program Location Object
    """
    schedule = objectify.SubElement(program_location_table, "Schedule")
    schedule.set("serviceIDRef", schedule["Schedule_att_serviceIDRef"])
    schedule.ScheduleEvent = ""
    schedule.ScheduleEvent.Program = ""
    schedule.ScheduleEvent.Program.set("crid", schedule["ScheduleScheduleEventProgram_att_crid"])
    schedule.ScheduleEvent.ProgramURL = schedule["ScheduleScheduleEventProgramURL"]
    schedule.ScheduleEvent.PublishedStartTime = schedule["ScheduleScheduleEventPublishedStartTime"]
    schedule.ScheduleEvent.PublishedEndTime = schedule["ScheduleScheduleEventPublishedEndTime"]
    program_location_table.append(schedule)

    return
